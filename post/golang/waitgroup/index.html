<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>golang源码分析-深入理解WaitGroup :: Leslie&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="WaitGroup介绍 实际开发中经常会碰到一种情况：一个聚合信息的接口(如app首页/用户信息等)，需要查询一大堆数据，而这些数据都是分散在各个服务中。同步去一个一个查询会导致接口响应过长。于是很自然而然想到了并发查询。
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/post/golang/waitgroup/" />





  
  <link rel="stylesheet" href="/css/terminal.min.fc24a2ba377236b213ad9dc657b53908a87eee2a32413a890db0dd1138479a4e.css">

  
  <link rel="stylesheet" href="/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="here-Leslie-Lau" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="golang源码分析-深入理解WaitGroup">
<meta property="og:description" content="WaitGroup介绍 实际开发中经常会碰到一种情况：一个聚合信息的接口(如app首页/用户信息等)，需要查询一大堆数据，而这些数据都是分散在各个服务中。同步去一个一个查询会导致接口响应过长。于是很自然而然想到了并发查询。
" />
<meta property="og:url" content="/post/golang/waitgroup/" />
<meta property="og:site_name" content="Leslie&#39;s Blog" />

  <meta property="og:image" content="/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="golang" />


  <meta property="article:published_time" content="2024-06-21 10:21:29 &#43;0800 &#43;0800" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post">
  <div class="logo">
    Leslie&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/categories">Categories</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/categories" >Categories</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/post/golang/waitgroup/">golang源码分析-深入理解WaitGroup</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-06-21</time><span class="post-author">here-Leslie-Lau</span><span class="post-reading-time">6 min read (2571 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="/tags/golang/">golang</a>&nbsp;
      
      #<a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        TOC
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#waitgroup介绍">WaitGroup介绍</a></li>
    <li><a href="#基本使用">基本使用</a></li>
    <li><a href="#源码实现">源码实现</a>
      <ul>
        <li><a href="#结构体定义">结构体定义</a></li>
        <li><a href="#add">Add</a></li>
        <li><a href="#done">Done</a></li>
        <li><a href="#wait">Wait</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="waitgroup介绍">WaitGroup介绍<a href="#waitgroup介绍" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>实际开发中经常会碰到一种情况：一个聚合信息的接口(如app首页/用户信息等)，需要查询一大堆数据，而这些数据都是分散在各个服务中。同步去一个一个查询会导致接口响应过长。于是很自然而然想到了并发查询。</p>
<p><img src="/icons/wait_group_01.png" alt="并发查询"></p>
<p>针对这种场景，并发查询就需要做好并发控制，确保所有的查询都完成后再返回结果。这时候就需要用到<code>sync.WaitGroup</code>。(主角登场)</p>
<p>事实上，<code>WaitGroup</code>这个并发原语特别常见，在linux中就有类似的<code>barrier</code>机制。可见这种需要一个线程等待一组线程完成的场景是非常常见的。所以本文就来深入理解一下<code>WaitGroup</code>的应用与实现。</p>
<h2 id="基本使用">基本使用<a href="#基本使用" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><em>本文的golang源码基于go1.22</em></p>
<p>既然要学习一个东西的实现原理，那么肯定需要先知道它是怎么使用的，先看看<code>WaitGroup</code>对外暴露了哪些方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ go doc sync.Waitgroup
</span></span><span class="line"><span class="cl">package sync // import <span class="s2">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">type</span> WaitGroup struct <span class="o">{</span>
</span></span><span class="line"><span class="cl">        // Has unexported fields.
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">    A WaitGroup waits <span class="k">for</span> a collection of goroutines to finish. The main
</span></span><span class="line"><span class="cl">    goroutine calls Add to <span class="nb">set</span> the number of goroutines to <span class="nb">wait</span> <span class="k">for</span>. Then each
</span></span><span class="line"><span class="cl">    of the goroutines runs and calls Done when finished. At the same time,
</span></span><span class="line"><span class="cl">    Wait can be used to block <span class="k">until</span> all goroutines have finished.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    A WaitGroup must not be copied after first use.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    In the terminology of the Go memory model, a call to Done “synchronizes
</span></span><span class="line"><span class="cl">    before” the <span class="k">return</span> of any Wait call that it unblocks.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func <span class="o">(</span>wg *WaitGroup<span class="o">)</span> Add<span class="o">(</span>delta int<span class="o">)</span>
</span></span><span class="line"><span class="cl">func <span class="o">(</span>wg *WaitGroup<span class="o">)</span> Done<span class="o">()</span>
</span></span><span class="line"><span class="cl">func <span class="o">(</span>wg *WaitGroup<span class="o">)</span> Wait<span class="o">()</span>
</span></span></code></pre></div><p>上面的英文注释已经很清晰了，<code>WaitGroup</code>是用来等待一组goroutine完成的。主goroutine调用<code>Add</code>方法设置等待的goroutine数量，然后每个goroutine运行并在完成后调用<code>Done</code>。同时，<code>Wait</code>可以用来在主goroutine进行阻塞，直到所有goroutine完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Calculator</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Cnt</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Calculator</span><span class="p">)</span> <span class="nf">Inc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">Cnt</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 先初始化一个WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cal</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Calculator</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 每次开一个协程前先加一个需要等待的goroutine数量</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 协程逻辑完成后调用Done, 表示该协程完成</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 协程具体的业务逻辑</span>
</span></span><span class="line"><span class="cl">			<span class="nx">cal</span><span class="p">.</span><span class="nf">Inc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 主协程调用Wait, 来阻塞自己，等待所有协程完成</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// output: 10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;res:&#34;</span><span class="p">,</span> <span class="nx">cal</span><span class="p">.</span><span class="nx">Cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里写了个demo, 用来展示<code>WaitGroup</code>的基本使用。具体的用法在代码中的注释里了。需要注意的是，通过<code>Add</code>方法设置等待者数量时，可以在每次开协程前调用(每次开之前加一)，也可以在循环外部调用(一次性加完)。</p>
<h2 id="源码实现">源码实现<a href="#源码实现" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="结构体定义">结构体定义<a href="#结构体定义" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><code>WaitGroup</code>的结构体定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint64</span> <span class="c1">// high 32 bits are counter, low 32 bits are waiter count.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span>  <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第一个字段<code>noCopy</code>是一个实现<code>sync.Locker</code>接口的空结构体。目的只是为了在<code>WaitGroup</code>被复制时，可以通过<code>go vet</code>检测出来。各位以后编程也可以使用这个技巧，避免不小心复制了一个不应该复制的对象(通过实现<code>Locker</code>接口)。</p>
<p>第二个字段是关键了，<code>state</code>是一个复合型字段，类似于<code>sync.Mutex.state</code>，一个字段有多种含义。该字段总共有16个字节，前8个字节(高32位)用来存储协程数量，后8个字节(低32位)用来存储等待者数量。</p>
<p>第三个字段<code>sema</code>是信号量，用来阻塞/唤醒主协程。</p>
<h3 id="add">Add<a href="#add" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>这里去除了一些竞态检测的代码，因为那不是本文重点，只保留关键逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: negative WaitGroup counter&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// This goroutine has set counter to 0 when waiters &gt; 0.</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Now there can&#39;t be concurrent mutations of state:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// - Adds must not happen concurrently with Wait,</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// - Wait does not increment waiters if it sees counter == 0.</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Still do a cheap sanity check to detect WaitGroup misuse.</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Reset waiters count to 0.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">;</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>接下来逐行解释一下：</p>
<ol>
<li>先通过<code>state.Add</code>方法将协程数量加上。至于为什么要左移32位，是因为<code>state</code>的高32位存储协程数量，低32位存储等待者数量(上文说过)。</li>
<li>v是协程数量(取state右移32位的结果)，w是等待者数量(取state的低32位)。</li>
<li>判断协程数量是否为负数，如果是则panic。这个判断比较好理解，因为如果协程数量为负了，那么主协程还在阻塞啥呢，不就死锁了吗。</li>
<li>如果等待者不为0，且协程数量等于delta，说明<code>Add</code>方法和<code>Wait</code>方法同时调用了(下文会说明<code>Wait</code>方法会操作等待者数量)，panic。为啥要加这个检测呢？是因为要确保<code>Wait</code>调用必须要在所有<code>Add</code>之后，不然可能会发生类似于&quot;死锁&quot;的情况。</li>
<li>如果协程数量大于0或者等待者数量为0，直接返回。这里的逻辑是，如果协程数量大于0，说明还有协程在运行，不需要唤醒等待者；如果等待者数量为0，说明没有等待者，也不需要唤醒。</li>
<li>程序运行到这里，说明此时协程数量为0并且等待者数量不为0。这时候再做一个检测，确保<code>Add</code>方法和<code>Wait</code>方法没有并发调用。如果有并发调用，panic。具体是取出此时的<code>state</code>和之前的<code>state</code>进行比较，如果不一致，说明此时<code>Wait</code>方法被调用了。</li>
<li>设置<code>state</code>为0，同时唤醒所有等待者。</li>
</ol>
<p>总体来看，<code>Add</code>方法的逻辑比较清晰。大致就是给高32位加上你设置的值，然后判断是否直接返回，如果协程数量为0那就唤醒等待者。</p>
<h3 id="done">Done<a href="#done" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Done decrements the WaitGroup counter by one.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Done</code>方法就是调用<code>Add(-1)</code>，减少协程数量。为啥减一呢？因为这个<code>Done</code>方法是每个协程处理完逻辑后调用的，所以减一。</p>
<p>刚刚看<code>Add</code>实现时，如果协程数量为0就会去唤醒等待者。其实就是所有协程处理完逻辑后，调用<code>Done</code>方法，协程数量减为0，然后唤醒等待者。</p>
<p>于是我们猜测，调用<code>Wait</code>方法时会阻塞等待者，直到协程数量为0时<code>Add</code>方法再将其唤醒。</p>
<p>验证猜想，接下来看<code>Wait</code>方法的实现。</p>
<h3 id="wait">Wait<a href="#wait" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>这里也是去除了一些竞态检测的代码，只保留关键逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Wait blocks until the WaitGroup counter is zero.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Counter is 0, no need to wait.</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Increment waiters count.</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">state</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">sema</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>先取出<code>state</code>，然后取出协程数量(v)和等待者数量(w)。</li>
<li>如果协程数量为0，直接返回。这个逻辑很好理解，如果协程数量为0，说明所有协程都处理完了，不需要等待。</li>
<li>CAS操作，将等待者数量加1。如果没成功，则下一次循环再次尝试，这也是有个无限for循环的原因。</li>
<li>阻塞当前协程</li>
<li>唤醒后判断当前<code>state</code>是否为0，如果不为0，说明<code>WaitGroup</code>被复用了(有其他地方在本次<code>Wait</code>还没结束时就调用了<code>Add</code>)，panic。</li>
<li>结束</li>
</ol>
<h2 id="总结">总结<a href="#总结" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>一句话总结，<code>Add</code>方法操作<code>state</code>的高32位。<code>Wait</code>方法操作<code>state</code>的低32位。<code>Done</code>方法就是<code>Add(-1)</code>。最后再加上一些检测逻辑。</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© <a href='https://github.com/here-Leslie-Lau' target='_blank' rel='noopener'>here-Leslie-Lau</a> || <a href='mailto:i.leslie.lau@gmail.com' target='_blank' rel='noopener'>Contact My Email</a'></span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
