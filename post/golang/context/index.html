<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>golang源码分析-Context :: Leslie&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="前言 平时写代码或者阅读代码的时候，经常会在方法内看到ctx context.Context这样的参数。本文就记录一下有关于context.Context的知识。
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/post/golang/context/" />





  
  <link rel="stylesheet" href="/css/terminal.min.fc24a2ba377236b213ad9dc657b53908a87eee2a32413a890db0dd1138479a4e.css">

  
  <link rel="stylesheet" href="/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="here-Leslie-Lau" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="golang源码分析-Context">
<meta property="og:description" content="前言 平时写代码或者阅读代码的时候，经常会在方法内看到ctx context.Context这样的参数。本文就记录一下有关于context.Context的知识。
" />
<meta property="og:url" content="/post/golang/context/" />
<meta property="og:site_name" content="Leslie&#39;s Blog" />

  <meta property="og:image" content="/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="golang" />


  <meta property="article:published_time" content="2023-05-20 16:24:27 &#43;0800 &#43;0800" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post">
  <div class="logo">
    Leslie&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/categories">Categories</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/categories" >Categories</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/post/golang/context/">golang源码分析-Context</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-05-20</time><span class="post-author">here-Leslie-Lau</span><span class="post-reading-time">13 min read (6402 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="/tags/golang/">golang</a>&nbsp;
      
      #<a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        TOC
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#what-context">What Context</a></li>
    <li><a href="#why-context">Why Context</a></li>
    <li><a href="#context接口">Context接口</a></li>
    <li><a href="#context类型">Context类型</a>
      <ul>
        <li><a href="#emptyctx">emptyCtx</a></li>
        <li><a href="#使用示例">使用示例</a></li>
        <li><a href="#canceler接口">canceler接口</a></li>
      </ul>
    </li>
    <li><a href="#context使用技巧">Context使用技巧</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="前言">前言<a href="#前言" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>平时写代码或者阅读代码的时候，经常会在方法内看到<code>ctx context.Context</code>这样的参数。本文就记录一下有关于<code>context.Context</code>的知识。</p>
<p><em>tips:本文源码基于golang 1.18</em></p>
<hr>
<h2 id="what-context">What Context<a href="#what-context" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><code>context</code>主要有以下作用:</p>
<ol>
<li>可用于在不同协程(goroutine)中传递信息</li>
<li>设置超时处理</li>
<li>控制协程退出</li>
</ol>
<p><code>context</code>字面量为上下文，准确点说它是goroutine的上下文。</p>
<blockquote>
<p>context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。
与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行。</p></blockquote>
<p>go语言中，<code>context</code>可以形成一个树形结构。这个树形结构的每一个节点都是一个<code>context</code>对象，它们可以互相嵌套，形成一个完整的上下文链。</p>
<p>这种树形结构的最大优点是，当我们在处理请求时，可以将不同的处理器分别绑定到对应的Context对象上，并且可以共享父级Context对象所包含的请求数据。这样，在请求超时或取消时，所有的处理器都可以响应并进行清理工作。</p>
<p>此外，Context对象的树形结构还支持一些其他的特性，比如：</p>
<ul>
<li>
<p>父级Context对象的取消操作会自动传播到所有的子级Context对象。</p>
</li>
<li>
<p>子级Context对象的取消操作不会影响父级Context对象和其他兄弟级别的Context对象。</p>
</li>
<li>
<p>可以通过调用Context对象的Value方法来获取父级Context对象所存储的请求范围的数据。</p>
</li>
</ul>
<p>总之，Context对象的树形结构是Go语言中非常重要的一种机制，它可以帮助我们有效地管理请求的上下文数据，并且可以在请求超时或取消时自动清理资源。</p>
<p><img src="/icons/context_06.png" alt="父子context描述"></p>
<hr>
<h2 id="why-context">Why Context<a href="#why-context" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>在之前的一篇<a href="https://here-leslie-lau.github.io/post/golang/http_server/">文章</a>中介绍到：在golang中每个http请求都会启一个goroutine来处理请求。</p>
<p>而每个处理请求的goroutine可能还会依赖其他服务(数据库、其他子服务等)，可能还会继续启用一个又一个的goroutine来进行处理:</p>
<p><img src="/icons/context_01.png" alt="一个http请求链条示例"></p>
<p>这里http请求进来后开启了一个a协程，a又开启了b,c,d(称为下游协程)等等。如果某个下游协程处理时间过长，那么a就只能一直在等待。而一个服务肯定不只有一个请求进来，还会有大量的请求。最终会造成大量的协程等待阻塞。</p>
<p>协程是要消耗内存和其他系统资源的，这种情况下会把资源耗尽，最终造成服务不可用，也称为&quot;雪崩效应&quot;。</p>
<p>如果有一种办法，可以控制a等待下游协程处理的时间，处理过久就不等待下游直接返回响应，防止协程堆积。</p>
<p><img src="/icons/context_02.png" alt="context设置超时处理"></p>
<p><code>context</code>在这里就发挥作用了。(<strong>设置超时处理</strong>)</p>
<p>还有几种情况，不同的goroutine需要共享一些信息，可以通过<code>context</code>来完成，比如在多个goroutine中共享用户的token。(<strong>在不同goroutine中传递信息</strong>)</p>
<p><img src="/icons/context_03.png" alt="context共享信息"></p>
<p>当一个上游协程发生某些情况需要退出时，需要告知它的下游协程及时退出，因为此时下游的工作已经没有意义了，则可以通过<code>context</code>来完成。(<strong>控制协程退出</strong>)</p>
<p><img src="/icons/context_04.png" alt="context控制协程退出"></p>
<hr>
<h2 id="context接口">Context接口<a href="#context接口" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><code>context</code>接口定义如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// A Context carries a deadline, a cancellation signal, and other values across</span>
</span></span><span class="line"><span class="cl"><span class="c1">// API boundaries.</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Context&#39;s methods may be called by multiple goroutines simultaneously.</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>根据注释描述可以知道: <code>context</code>可以跨api边界传递截止日期、取消信号、和其他值。并且<code>context</code>的方法可以被多个goroutine同时调用，它是并发安全的。</p>
<p>该接口有四个方法，简单一个个介绍下。</p>
<ol>
<li>
<p><code>Deadline</code>方法会返回一个<code>time.Time</code>实例，代表这个上下文的截止日期。在这个时间点之后，上下文会被取消。第二个返回值如果为false则代表该上下文没有设置截止日期。拿到这个截止日期之后，能判断是否可以执行后续操作，如果可以则给后续的操作设置超时时间。</p>
</li>
<li>
<p><code>Done</code>方法返回一个<code>channel</code>。如果该<code>channel</code>被关闭则代表该上下文被取消了。这个方法是核心，在golang中一个<code>channel</code>如果被关闭，则会发送空值。<code>context</code>正是用到了这一特性，我们可以在方法内监听<code>ctx.Done</code>，如果接收到值则代表context被取消，那么则做一些资源关闭处理。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;lalala&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// close resourse</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>
<p><code>Err</code>: 上文说到<code>Done</code>方法会返回一个<code>channel</code>。如果该<code>channel</code>被关闭了则代表ctx被取消，<code>Err</code>方法会返回<code>channel</code>被关闭的原因。<code>Canceled</code>代表ctx被手动取消的，<code>DeadlineExceeded</code>代表该ctx因为超时而取消的。如果该方法返回一个非nil的错误后，后续的多次调用都返回相同的值。</p>
</li>
<li>
<p><code>Value</code>:该方法会返回一个与参数<code>key</code>相对应的值，把它理解为<code>context</code>中的一个map即可。需要注意，这个map应该只保存和跨边界api相关的请求数据，如<code>token,uid</code>等。业务数据不应该保存至map中。可以使用如下方法储存:</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// 第一个参数为父context, context.TODO()类型下文再介绍。key为abc, value为123</span>
</span></span><span class="line"><span class="cl"><span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">TODO</span><span class="p">(),</span> <span class="s">&#34;abc&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 取到的value强转为int类型</span>
</span></span><span class="line"><span class="cl"><span class="nx">result</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">).(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span></code></pre></div><hr>
<h2 id="context类型">Context类型<a href="#context类型" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>上一个章节记录了<code>Context</code>接口，那么肯定会有对应的实现，这一章节介绍几个<code>Context</code>实现与具体的实现机制。</p>
<h3 id="emptyctx">emptyCtx<a href="#emptyctx" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>先介绍一下<code>emptyCtx</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// emptyCtx是一个空的context对象，它永远不会被取消，没有任何值，也没有任何截止日期。它不是struct{}类型，因为该类型的变量必须具有不同的地址。</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">emptyCtx</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它实现了<code>Context</code>接口，只不过每个方法都为空实现。意味着该ctx永远不会被取消。</p>
<p>平时我们常用的<code>context.Background()</code>和<code>context.TODO()</code>底层就是<code>emptyCtx</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">background</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TODO</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">todo</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Background</code>常用于main函数、初始化、http请求的底层Context。它应该作为一个项目的根Context，后续的Context都作为它的子Context而存在。</p>
<p><code>TODO</code>本质上与<code>Background</code>没有区别，只不过前者更偏向语义化的含义，当你不知道使用什么Context对象时，可以使用<code>TODO</code>临时替代。</p>
<h3 id="使用示例">使用示例<a href="#使用示例" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>平时在学习与工作中主要是这样使用<code>context</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// case 1:</span>
</span></span><span class="line"><span class="cl"><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">DoSomeThing</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// case 2:</span>
</span></span><span class="line"><span class="cl"><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">DoSomeThing</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// case 3:</span>
</span></span><span class="line"><span class="cl"><span class="nx">deadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">deadline</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">DoSomeThing</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span></code></pre></div><p>示例中使用了三个方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span>
</span></span></code></pre></div><p><code>WithCancel</code>方法返回一个parent的副本(相当于parent的子ctx)与一个关闭子ctx的函数。调用这个函数或者parent被取消(parent的Done被关闭)的话，子ctx就被取消。因此代码应该在正在运行的操作完成后尽快调用 cancel 函数，或者使用<code>defer</code>关闭ctx。下面两个方法也是一样，略。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span>
</span></span></code></pre></div><p><code>WithDeadline</code>方法要求传入一个父ctx(parent)与截止时间(<code>time.Time</code>对象)。返回一个带有截止时间的子ctx与关闭子ctx的函数。这个截止时间就是传进去的<code>time.Time</code>对象。当截止时间到达、调用返回的 cancel 函数或者父ctx的 Done 通道关闭时，返回的ctx也会被取消。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span>
</span></span></code></pre></div><p><code>WithTimeout</code>方法返回结果与<code>WithDeadline</code>一样，请求参数变成父ctx与<code>time.Duration</code>对象。代表返回的子ctx多久后超时被取消。</p>
<p>我们可以用上面三个方法来控制goroutine的操作时间(设置deadline或者timeout)或主动退出(调用cancel)。</p>
<h3 id="canceler接口">canceler接口<a href="#canceler接口" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>知道了怎么使用<code>context</code>，但是还需要知其所以然。本章节主要在源码层面分析<code>context</code>取消的实现。</p>
<p>这里介绍一个重要的接口:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>canceler</code>是一个可以直接被取消的<code>context</code>类型。具体的实现有<code>*cancelCtx</code>和<code>*timerCtx</code>两种。</p>
<p><code>Done()</code>方法和<code>Context</code>接口的含义一样，这里跳过。<code>cancel</code>方法表示取消ctx，第一个参数代表是否从父ctx中去除，第二个参数代表取消的原因。</p>
<p>接下来看该接口的两个实现类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// cancelCtx可以被取消，当它被取消时，也会取消实现了canceler接口的子ctx</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Context</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>            <span class="c1">// 保护下面的字段，确保并发安全</span>
</span></span><span class="line"><span class="cl">	<span class="nx">done</span>     <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>          <span class="c1">// 懒加载创建的，它是一个 chan struct{} 类型的通道，在第一次调用取消函数时关闭。</span>
</span></span><span class="line"><span class="cl">	<span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// 第一次调用取消函数时置为nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// 第一次调用取消函数是置为non-nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="cancelctx">cancelCtx<a href="#cancelctx" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>第一个是<code>cancelCtx</code>，它的字段含义都注释在上面的代码块里了。主要看它如何实现<code>canceler</code>接口的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 参数判断</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;context: internal error: missing cancel error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 并发控制</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// err不为空，说明之前就被取消了</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="c1">// already canceled</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 给err赋值</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 懒加载创建done</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">closedchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 关闭d</span>
</span></span><span class="line"><span class="cl">		<span class="nb">close</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 将子ctx关闭</span>
</span></span><span class="line"><span class="cl">		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 清楚父子ctx映射</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 从父ctx移除</span>
</span></span><span class="line"><span class="cl">		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>cancelCtx</code>的<code>cancel</code>会关闭它自己的done(代表被取消了)，接着关闭所有的子ctx。如果第一个参数为true则会从父ctx中移除。</p>
<p>逻辑注释在代码里了，这个方法大致做这几件事:</p>
<ol>
<li>参数判断</li>
<li>懒加载创建done</li>
<li>调用子ctx的cancel, 取消子ctx</li>
<li>判断是否从父ctx中移除</li>
</ol>
<p><code>Done</code>的实现就是懒加载一个<code>chan struct{}</code>类型返回，代码就不放了。</p>
<p>现在来看<code>WithCancel</code>的实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 参数校验</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个cancelCtx的实例</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 该方法判断, 当传入的父ctx被取消时, 该cancelCtx也被取消</span>
</span></span><span class="line"><span class="cl">	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 返回cancelCtx与它的cancel方法</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>先是参数校验，接着创建一个<code>cancelCtx</code>实例然后判断传入的父ctx有没有被取消。最后返回<code>cancelCtx</code>自己和它的<code>cancel</code>方法。这个实现就是上面介绍的。第一个参数传true代表会从父ctx中移除自己，第二个参数传的是<code>errors.New(&quot;context canceled&quot;)</code>，代表取消原因。</p>
<h4 id="timerctx">timerCtx<a href="#timerctx" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cancelCtx</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 受cancelCtx.mu的保护</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>timerCtx</code>相比于<code>cancelCtx</code>，多了个timer和deadline。timer会在deadline到来时，自动取消ctx。</p>
<p>看下<code>timerCtx.cancel</code>方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 直接调用cancelCtx取消ctx</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 从父ctx中移除</span>
</span></span><span class="line"><span class="cl">		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 将定时器关闭并置空</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第一步直接调用<code>cancelCtx.cancel</code>方法，来取消ctx。接着判断是否从父ctx中移除。最后将timer关闭，这里先是判nil，防止重复关闭。</p>
<p>而<code>timerCtx.Done</code>的实现和<code>cancelCtx.Done</code>一致，懒加载一个<code>chan struct{}</code>返回，这里就不贴代码了。</p>
<p>知道了<code>timerCtx</code>如何实现<code>canceler</code>接口，接下来看看<code>WithDeadline</code>与<code>WithTimeout</code>是如何创建<code>timerCtx</code>的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 参数判断</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 父ctx的deadline早于传入的d，直接构造无deadline的子ctx返回</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 因为父ctx到deadline后，会自动将子ctx取消，这里无需构造两个timer了</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 构造timerCtx实例</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 父子关系绑定</span>
</span></span><span class="line"><span class="cl">	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取距离d还有多久，dur为time.Duration</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 已经结束，直接取消</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// deadline has already passed</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 启动子ctx的timer，在dur之后运行cancel方法。</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 返回自身与cancel方法</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>还是一样，方法逻辑都注释在代码块里了，这里总结下：</p>
<ol>
<li>参数判断，判断父ctx的deadline是否早于传入的deadline</li>
<li>构造<code>timerCtx</code>实例，绑定父子关系</li>
<li>获取当前时间距离传入的deadline还有多久(dur)</li>
<li>如果dur&lt;0代表已经超时，直接取消并返回。dur&gt;0则启动timer，在dur之后运行<code>timerCtx.cancel</code>方法。</li>
<li>方法返回<code>timerCtx</code>与<code>timerCtx.cancel</code>，使用者可以主动取消</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>WithTimeout</code>这里是直接调用了<code>WithDeadline</code>，参数传的是当前时间加上timeout。</p>
<h4 id="valuectx">valueCtx<a href="#valuectx" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>上面介绍<code>context</code>对外方法时，只介绍了<code>WithCancel</code>,<code>WithDeadline</code>,<code>WithTimeout</code>。还剩一个<code>WithValue</code>。再介绍它前，需要介绍下<code>valueCtx</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Context</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>valueCtx</code>拥有一个内嵌的<code>ctx</code>与一个键值对(<code>key,value</code>)。可以通过<code>key</code>找到对应的<code>value</code>，并将除<code>context.Value(key)</code>方法的其他调用都委托给内嵌的<code>ctx</code>。</p>
<p><code>valueCtx.Value(key)</code>的实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果传入的key等于valueCtx自身的key，则将自身的value返回</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 自身没有对应的value，去父节点找</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">value</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">value</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">any</span><span class="p">)</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 开启一个循环，判断c的类型</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 父节点还是valueCtx，判断逻辑与上面一致</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">val</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 寻找父节点的父节点</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 判断传入的key是否等于cancelCtxKey</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 寻找父节点的父节点</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 判断传入的key是否等于cancelCtxKey</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">cancelCtx</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 寻找父节点的父节点</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span> <span class="p">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Context</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="o">*</span><span class="nx">emptyCtx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 空实现的ctx，直接返回nil</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法逻辑都注释好了，简单来说就是先看看自身(<code>valueCtx</code>)保存key能否匹配传入的key。如果可以就直接返回自身的value，否则去父节点找对应的key(类似递归的方式)。找到最后没找到就返回nil。</p>
<p>接下来看看<code>WithValue</code>函数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">any</span><span class="p">)</span> <span class="nx">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;cannot create context from nil parent&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第一步先参数校验，接着判断传入的key是不是可以比较的类型(如果不可比较，那么查找时会找不到，还存进去没意义)。最后生成一个<code>valueCtx</code>实例返回。</p>
<p><img src="/icons/context_05.png" alt="WithValue创建的ctx树"></p>
<p>如图所示，<code>WithValue</code>所构建的context树。每个节点都会携带一个键值对，如果本节点找不到则会去父节点寻找。这里我们不推荐使用<code>WithValue</code>保存一些业务数据，该函数只适合保存一些请求相关的信息(如request_id和trace_id)。原因有几个，一是链表查询时间复杂度位O(n)，查询效率不保证，二是子节点可能会持有和父节点相同的key，导致覆盖掉父节点的值了。</p>
<h2 id="context使用技巧">Context使用技巧<a href="#context使用技巧" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>以下摘自官方:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="mf">1.</span> <span class="nx">Do</span> <span class="nx">not</span> <span class="nx">store</span> <span class="nx">Contexts</span> <span class="nx">inside</span> <span class="nx">a</span> <span class="kd">struct</span> <span class="kd">type</span><span class="p">;</span> <span class="nx">instead</span><span class="p">,</span> <span class="nx">pass</span> <span class="nx">a</span> <span class="nx">Context</span> <span class="nx">explicitly</span> <span class="nx">to</span> <span class="nx">each</span> <span class="nx">function</span> <span class="nx">that</span> <span class="nx">needs</span> <span class="nx">it</span><span class="p">.</span> <span class="nx">The</span> <span class="nx">Context</span> <span class="nx">should</span> <span class="nx">be</span> <span class="nx">the</span> <span class="nx">first</span> <span class="nx">parameter</span><span class="p">,</span> <span class="nx">typically</span> <span class="nx">named</span> <span class="nx">ctx</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span> <span class="nx">Do</span> <span class="nx">not</span> <span class="nx">pass</span> <span class="nx">a</span> <span class="kc">nil</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">even</span> <span class="k">if</span> <span class="nx">a</span> <span class="nx">function</span> <span class="nx">permits</span> <span class="nx">it</span><span class="p">.</span> <span class="nx">Pass</span> <span class="nx">context</span><span class="p">.</span><span class="nx">TODO</span> <span class="k">if</span> <span class="nx">you</span> <span class="nx">are</span> <span class="nx">unsure</span> <span class="nx">about</span> <span class="nx">which</span> <span class="nx">Context</span> <span class="nx">to</span> <span class="nx">use</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span> <span class="nx">Use</span> <span class="nx">context</span> <span class="nx">Values</span> <span class="nx">only</span> <span class="k">for</span> <span class="nx">request</span><span class="o">-</span><span class="nx">scoped</span> <span class="nx">data</span> <span class="nx">that</span> <span class="nx">transits</span> <span class="nx">processes</span> <span class="nx">and</span> <span class="nx">APIs</span><span class="p">,</span> <span class="nx">not</span> <span class="k">for</span> <span class="nx">passing</span> <span class="nx">optional</span> <span class="nx">parameters</span> <span class="nx">to</span> <span class="nx">functions</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="mf">4.</span> <span class="nx">The</span> <span class="nx">same</span> <span class="nx">Context</span> <span class="nx">may</span> <span class="nx">be</span> <span class="nx">passed</span> <span class="nx">to</span> <span class="nx">functions</span> <span class="nx">running</span> <span class="nx">in</span> <span class="nx">different</span> <span class="nx">goroutines</span><span class="p">;</span> <span class="nx">Contexts</span> <span class="nx">are</span> <span class="nx">safe</span> <span class="k">for</span> <span class="nx">simultaneous</span> <span class="nx">use</span> <span class="nx">by</span> <span class="nx">multiple</span> <span class="nx">goroutines</span><span class="p">.</span>
</span></span></code></pre></div><p>翻译一下:</p>
<ol>
<li>不要将上下文存储在结构类型内；相反，对于每个需要它的函数，显式地传递上下文。上下文应该是第一个参数，通常命名为ctx。</li>
<li>即使函数允许，也不要传递空的上下文。如果您不确定使用哪个上下文，请传递context.TODO。</li>
<li>只将请求范围的数据（途经进程和 API）用作上下文值，不要将可选参数传递给函数。</li>
<li>相同的上下文可能会传递给在不同goroutine中运行的函数；上下文可以被多个goroutine同时使用，是安全的。</li>
</ol>
<p>到这里，goalng context包就介绍完毕了。整个包源码不多，非常适合学习阅读。</p>
<p>最后，大家下次在看到代码里有用到 context 的，观察下是怎么使用的，肯定逃不出我们讲的几种类型。熟悉之后会发现：context 可能并不完美，但它确实简洁高效地解决了问题。</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© <a href='https://github.com/here-Leslie-Lau' target='_blank' rel='noopener'>here-Leslie-Lau</a> || <a href='mailto:i.leslie.lau@gmail.com' target='_blank' rel='noopener'>Contact My Email</a'></span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
