<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>golang源码分析-启动一个http服务到底发生了什么？ :: Leslie&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="前言 本文将从golang的源码方面分析：如何启动http服务，这个服务是怎么对外提供服务的，以及为什么可以保证高性能。
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/post/golang/http_server/" />





  
  <link rel="stylesheet" href="/css/terminal.min.fc24a2ba377236b213ad9dc657b53908a87eee2a32413a890db0dd1138479a4e.css">

  
  <link rel="stylesheet" href="/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="/css/main.min.775ac2af004d44c22a6d000fbd1d9af529642f5cef27399d0280d180af2c2e9b.css">

  
  <link rel="stylesheet" href="/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="here-Leslie-Lau" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="golang源码分析-启动一个http服务到底发生了什么？">
<meta property="og:description" content="前言 本文将从golang的源码方面分析：如何启动http服务，这个服务是怎么对外提供服务的，以及为什么可以保证高性能。
" />
<meta property="og:url" content="/post/golang/http_server/" />
<meta property="og:site_name" content="Leslie&#39;s Blog" />

  <meta property="og:image" content="/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="golang" />


  <meta property="article:published_time" content="2023-05-16 11:20:01 &#43;0800 &#43;0800" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/post">
  <div class="logo">
    Leslie&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/categories">Categories</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/categories" >Categories</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/post/golang/http_server/">golang源码分析-启动一个http服务到底发生了什么？</a>
  </h1>
  <div class="post-meta"><time class="post-date">2023-05-16</time><span class="post-author">here-Leslie-Lau</span><span class="post-reading-time">8 min read (3968 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="/tags/golang/">golang</a>&nbsp;
      
      #<a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        TOC
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#http协议介绍">http协议介绍</a></li>
    <li><a href="#golang内启动http服务">golang内启动http服务</a></li>
    <li><a href="#源码分析">源码分析</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="前言">前言<a href="#前言" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>本文将从golang的源码方面分析：如何启动http服务，这个服务是怎么对外提供服务的，以及为什么可以保证高性能。</p>
<p>这里先附上平时看源码的一个小技巧：</p>
<ol>
<li>先看库对外暴露的方法(了解该库提供了哪些功能)</li>
<li>再看库有哪些核心的结构(该库提供的功能肯定依赖于某种数据结构)</li>
<li>最后看这些核心结构有哪些私有方法(核心的数据结构它是如何实现功能的)</li>
</ol>
<blockquote>
<p>本文代码基于golang 1.18</p></blockquote>
<hr>
<h2 id="http协议介绍">http协议介绍<a href="#http协议介绍" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>这里只是简单介绍下该协议是啥，更详细的可以参考互联网。</p>
<p>Hypertext Transfer Protocol(超文本传输协议)。我对这个名词的理解是这个东西本质是字符串，但是它又不只是字符串而有更加深刻的含义。所以叫超文本[doge]</p>
<p>大白话就是，它是一个应用层的通信协议。现在两台计算机要互相通信，肯定需要遵守某种规范，http就是这种规范。</p>
<p><img src="/icons/http_demo.png" alt="asd"></p>
<p>它基于传输层的tcp协议。大致的请求步骤如下:</p>
<ol>
<li>客户端通过http请求向服务器发起通信</li>
<li>服务器接收到请求后，处理请求</li>
<li>将处理的结果封装并响应给客户端</li>
</ol>
<p>基本上就是一问一答的模式，至于<code>http2</code>之后支持的双向通信，这不再本文讨论的范围</p>
<hr>
<h2 id="golang内启动http服务">golang内启动http服务<a href="#golang内启动http服务" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>第一种方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">PingHandler</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">PingHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;pong&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/ping&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">PingHandler</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第二种方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/ping&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;pong&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>两种方式启动http都特别简单，只需要几行代码即可。接下来我们一一看。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Handle</span> <span class="nx">registers</span> <span class="nx">the</span> <span class="nx">handler</span> <span class="k">for</span> <span class="nx">the</span> <span class="nx">given</span> <span class="nx">pattern</span> <span class="nx">in</span> <span class="nx">the</span> <span class="nx">DefaultServeMux</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="nx">The</span> <span class="nx">documentation</span> <span class="k">for</span> <span class="nx">ServeMux</span> <span class="nx">explains</span> <span class="nx">how</span> <span class="nx">patterns</span> <span class="nx">are</span> <span class="nx">matched</span><span class="p">.</span>
</span></span></code></pre></div><p>方式一使用到了<code>Handle</code>函数，这个函数定义如上，本质上是为了注册路径和处理器之间的映射。在方式1的例子中，我们向<code>localhost:8080/ping</code>路径注册了<code>PingHandler</code>，这个<code>PingHandler</code>实现了<code>http.Handler</code>接口，也就是<code>Handle</code>函数的第二个参数。</p>
<p><code>http.Handler</code>接口定义:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">A</span> <span class="nx">Handler</span> <span class="nx">responds</span> <span class="nx">to</span> <span class="nx">an</span> <span class="nx">HTTP</span> <span class="nx">request</span><span class="p">.</span>
</span></span></code></pre></div><p>这个接口只有一个方法，叫<code>ServeHTTP</code>。意为处理HTTP请求，参数一是响应封装，参数二是HTTP请求封装。例子中的<code>PingHandler</code>实现了该接口，当请求进来时，我们会回复一个<code>pong</code>字符串给客户端。</p>
<p>注册完路径和处理器之间的映射后，就需要启动服务了，启动服务需要调用该函数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ListenAndServe</span> <span class="nx">listens</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">TCP</span> <span class="nx">network</span> <span class="nx">address</span> <span class="nx">addr</span> <span class="nx">and</span> <span class="nx">then</span> <span class="nx">calls</span> <span class="nx">Serve</span>
</span></span><span class="line"><span class="cl">    <span class="nx">with</span> <span class="nx">handler</span> <span class="nx">to</span> <span class="nx">handle</span> <span class="nx">requests</span> <span class="nx">on</span> <span class="nx">incoming</span> <span class="nx">connections</span><span class="p">.</span> <span class="nx">Accepted</span>
</span></span><span class="line"><span class="cl">    <span class="nx">connections</span> <span class="nx">are</span> <span class="nx">configured</span> <span class="nx">to</span> <span class="nx">enable</span> <span class="nx">TCP</span> <span class="nx">keep</span><span class="o">-</span><span class="nx">alives</span><span class="p">.</span>
</span></span></code></pre></div><p>第一个参数是要监听的tcp网络地址，我们这里监听的是本机的8080端口，而<code>localhost</code>可以省略不写，所以就填入<code>:8080</code>。第二个参数下文再说，这里先填入nil</p>
<p>到此为止，http服务就启动成功了，你们可以复制代码测试下。接下来看方式二。方式二区别在于注册映射的时候，官方提供了一个语法糖。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">HandleFunc</span> <span class="nx">registers</span> <span class="nx">the</span> <span class="nx">handler</span> <span class="nx">function</span> <span class="k">for</span> <span class="nx">the</span> <span class="nx">given</span> <span class="nx">pattern</span> <span class="nx">in</span> <span class="nx">the</span>
</span></span><span class="line"><span class="cl">    <span class="nx">DefaultServeMux</span><span class="p">.</span> <span class="nx">The</span> <span class="nx">documentation</span> <span class="k">for</span> <span class="nx">ServeMux</span> <span class="nx">explains</span> <span class="nx">how</span> <span class="nx">patterns</span> <span class="nx">are</span>
</span></span><span class="line"><span class="cl">    <span class="nx">matched</span><span class="p">.</span>
</span></span></code></pre></div><p>这个函数和<code>Handle</code>函数类似，第一个参数还是请求路径，第二个参数则变成了一个处理函数。这个处理函数的签名和<code>http.Handler.ServeHTTP</code>一模一样，也就意味着我们不需要实现<code>http.Handler</code>接口，直接传入一个处理函数就可以注册了。</p>
<p>具体的可以参照上面的方式二，在实际中也推荐方式二。这样就不用每个路径都实现一次<code>http.Handler</code>接口。</p>
<hr>
<h2 id="源码分析">源码分析<a href="#源码分析" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>上文提到的两种注册路径与映射的函数，他们实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="p">{</span> <span class="nx">DefaultServeMux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">DefaultServeMux</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这两个函数都依赖了<code>DefaultServeMux</code>，它是<code>ServeMux</code>的实例，结构如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ServeMux</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 读写锁，保证并发安全</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 保存路径与处理器之间的映射</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span>     <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据路径长度从高到低给处理器排序</span>
</span></span><span class="line"><span class="cl">	<span class="nx">es</span>    <span class="p">[]</span><span class="nx">muxEntry</span> <span class="c1">// slice of entries sorted from longest to shortest.</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 是否有一个路径包含hostname</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hosts</span> <span class="kt">bool</span>       <span class="c1">// whether any patterns contain hostnames</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">muxEntry</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理器</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span>       <span class="nx">Handler</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 路径</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pattern</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>字段我注释在代码块上了，看字段也可以猜出，这个结构体就是保存路径和处理器的映射关系的。而<code>DefaultServeMux</code>是该结构体的一个默认值，它是一个全局变量，定义如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// DefaultServeMux is the default ServeMux used by Serve.</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">DefaultServeMux</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">defaultServeMux</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">defaultServeMux</span> <span class="nx">ServeMux</span>
</span></span></code></pre></div><p>这样设计的好处是使用者不需要了解具体的数据结构，直接调用函数即可完成注册。到这一步我们知道了调用<code>http.Handle</code>和<code>http.HandleFunc</code>是将路径和处理器注册到了<code>DefaultServeMux</code>上。</p>
<p>接下来继续往下看,<code>DefaultServeMux.HandleFunc</code>和<code>DefaultServeMux.Handle</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// HandleFunc registers the handler function for the given pattern.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">HandleFunc</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: nil handler&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">handler</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到<code>ServeMux.HandleFunc</code>只是判断了一下handler是否为空，然后就强转为<code>HandlerFunc</code>，接着调用<code>ServeMux.Handle</code>了。<code>HandlerFunc</code>就是上文说到的语法糖，那个和<code>http.Handler.ServeHTTP</code>一模一样的函数签名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// Handle registers the handler for the given pattern.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// If a handler already exists for pattern, Handle panics.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 并发控制</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断传入路径是否为空</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: invalid pattern&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断传入的处理器是否为空</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: nil handler&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断对应的路径之前是否注册过，如果注册过则panic</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: multiple registrations for &#34;</span> <span class="o">+</span> <span class="nx">pattern</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 懒加载ServeMux的映射map</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 给映射map赋值(key: pattern, value: handler)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">muxEntry</span><span class="p">{</span><span class="nx">h</span><span class="p">:</span> <span class="nx">handler</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">:</span> <span class="nx">pattern</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果路径的最后一位是/结尾的，则给es字段排序</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mux</span><span class="p">.</span><span class="nx">es</span> <span class="p">=</span> <span class="nf">appendSorted</span><span class="p">(</span><span class="nx">mux</span><span class="p">.</span><span class="nx">es</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果路径第一个字符不是/开始的，则设置hosts为true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mux</span><span class="p">.</span><span class="nx">hosts</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>逻辑都在上面的代码块里注释了，大致总结:</p>
<ol>
<li>使用mutex锁进行并发控制</li>
<li>各种校验(判断请求参数是否正确&hellip;)</li>
<li>保存映射关系至<code>ServeMux.m</code>中</li>
<li>检查路径看是否需要排序和设置hosts值</li>
</ol>
<p>路径和处理器的映射关系现在我们知道是怎么实现的了，核心就是保存在<code>ServeMux.m</code>中。只不过咱们调用<code>http.Handle</code>和<code>http.HandleFunc</code>的时候golang帮我们存到了一个全局变量<code>DefaultServeMux</code>中了。接下来看下是如何启动服务的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// ListenAndServe listens on the TCP network address addr and then calls</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Serve with handler to handle requests on incoming connections.</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Accepted connections are configured to enable TCP keep-alives.</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// The handler is typically nil, in which case the DefaultServeMux is used.</span>
</span></span><span class="line"><span class="cl"><span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ListenAndServe always returns a non-nil error.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span><span class="nx">Addr</span><span class="p">:</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">:</span> <span class="nx">handler</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将addr和handler保存至Server实例内，并调用Server.ListenAndServe</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到<code>ListenAndServe</code>的实现比较简单，还是要往下看<code>Server.ListenAndServe</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ListenAndServe</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">shuttingDown</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrServerClosed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Addr</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;:http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">ln</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到这个方法会对addr进行tcp监听，并且调用<code>Server.Serve</code>方法，接着看</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">l</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">tempDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// how long to sleep on accept failure</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">baseCtx</span><span class="p">,</span> <span class="nx">ServerContextKey</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rw</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">newConn</span><span class="p">(</span><span class="nx">rw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateNew</span><span class="p">,</span> <span class="nx">runHooks</span><span class="p">)</span> <span class="c1">// before Serve can return</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">serve</span><span class="p">(</span><span class="nx">connCtx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法有点长，所以我省略了一部分，直接看重要的逻辑。</p>
<p>for循环内有一个<code>rw, err := l.Accept()</code>。在socket编程内<code>accept</code>表示服务器接收一个请求并处理，所以这一行是为了接收来自客户端的请求。</p>
<p>接着<code>c := srv.newConn(rw)</code>是创建了一个<code>http.conn</code>的对象，然后通过协程调用<code>http.conn.serve</code>方法(因为有协程，所以高性能)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// Serve a new connection.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 读取请求参数</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">readRequest</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 将conn.server赋给serverHandler并调用serveHTTP进行处理</span>
</span></span><span class="line"><span class="cl">		<span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 结束请求</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">finishRequest</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateIdle</span><span class="p">,</span> <span class="nx">runHooks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">response</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个方法也是直接看核心逻辑，先读取请求，然后调用<code>http.serverHandler.ServeHTTP</code>。该方法底层也是调用了<code>http.Handler.ServeHTTP</code>。</p>
<p>到这里仍然有一个问题，我们最开始<code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>的第二个参数传的是nil，那最后<code>nil.ServeHTTP</code>不是会空指针吗？</p>
<p>看看<code>http.serverHandler.ServeHTTP</code>里面是怎么做的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">sh</span> <span class="nx">serverHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">handler</span> <span class="o">:=</span> <span class="nx">sh</span><span class="p">.</span><span class="nx">srv</span><span class="p">.</span><span class="nx">Handler</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果为空, 则赋值为DefaultServeMux</span>
</span></span><span class="line"><span class="cl">		<span class="nx">handler</span> <span class="p">=</span> <span class="nx">DefaultServeMux</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用ServeHTTP方法</span>
</span></span><span class="line"><span class="cl">	<span class="nx">handler</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果为nil，该nil会变为DefaultServeMux。然后再调用<code>DefaultServeMux.ServeHTTP</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="c1">// ServeHTTP dispatches the request to the handler whose</span>
</span></span><span class="line"><span class="cl"><span class="c1">// pattern most closely matches the request URL.</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...略</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据请求找到对应的处理器</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用处理器的ServeHTTP方法处理请求</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法的逻辑补充到注释上了。至此golang中路径与处理器如何匹配注册、http服务如何启动、请求进来后如何找到对应的处理器并处理请求，都理清楚了。大致总结下:</p>
<ol>
<li>通过<code>http.Handle</code>或<code>http.HandleFunc</code>函数注册请求路径与处理器的映射关系，保存在ServeMux.m字段内</li>
<li>调用<code>http.ListenAndServe</code>函数启动服务，传入监听的tcp地址和一个<code>http.Handler</code>实例，如果为nil，则使用标准库的<code>http.DefaultServeMux</code></li>
<li>函数内部会启用一个for循环，监听来自客户端的socket连接(accept)。如果检测到请求则开启协程去处理</li>
<li>协程内部调用<code>http.DefaultServeMux</code>的<code>ServeHTTP</code>去处理</li>
<li>而<code>http.DefaultServeMux.ServeHTTP()</code>实现是：根据请求路径找到最合适的处理器去处理请求(比如例子中根据<code>/ping</code>路径找到了<code>PingHandler{}</code>)</li>
</ol>
<p>我们注意到<code>http.ListenAndServe</code>会要求传入<code>http.Handler</code>，传nil默认使用标准库的<code>DefaultServeMux</code>来进行请求路径的分发处理。咱们可以基于这个来定至自己的<code>ServeMux</code>，自己给请求分发器增加功能(如路由分组等等)。事实上<a href="https://github.com/gorilla/mux">mux仓库</a>也是这么做的。</p>
<p>本文总结完毕，如有不太明白的可以直接在评论区交流~</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© <a href='https://github.com/here-Leslie-Lau' target='_blank' rel='noopener'>here-Leslie-Lau</a> || <a href='mailto:i.leslie.lau@gmail.com' target='_blank' rel='noopener'>Contact My Email</a'></span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
